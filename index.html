<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Using dry-monads Result for Error Handling</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/beige.css">
    <link rel="stylesheet" href="dist/layout.css">
    <link rel="stylesheet" href="dist/code.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
        <section data-auto-animate>
          <h2>dry-monads / Result</h2>

          <img src="images/cat-box.gif">
          <pre data-id="def-result"><code data-trim data-line-numbers class="ruby">
            Success(x)
            Failure(e)
          </code></pre>

          <aside class="notes" data-markdown>
            We're only mentioning the Result monad in the dry-monads lib.

            Result is a box that contains a value.

            Result has 2 possible values (Success, Failure) and bias toward the Success value.
          </aside>
        </section>
        <section data-auto-animate>
          <h2>dry-monads / Result</h2>

          <pre data-id="def-result"><code data-trim data-line-numbers="1|1-2|*" class="ruby">
            f(x) #=> Success(y)
            Success(x).bind(f) #=> Success(y)
            Failure(e).bind(f) #=> Failure(e)
          </code></pre>
          <pre class="fragment"><code data-trim data-line-numbers class="ruby">
            g(x) #=> Failure(ew)
            Success(x).bind(g) #=> Failure(ew)
            Failure(e).bind(g) #=> Failure(e)
          </code></pre>

          <aside class="notes" data-markdown>
            With a function f ..., Success & Failure behave ...

            So with a function g ..., they behave ...
          </aside>
        </section>
        <section>
          <h2>Recurring problem</h2>
          <code>h(g(f(x)))</code>
          <p class="fragment" data-fragment-index="1">&dArr;</p>
          <code class="fragment" data-fragment-index="1">(f&bull;g&bull;h)(x)</code>
          <p class="fragment" data-fragment-index="2">&dArr;</p>
          <code class="fragment" data-fragment-index="2">f(x).bind(g).bind(h)</code>

          <aside class="notes" data-markdown>
            Monads in general solve the recurring problem.
            Problem is nested function calls with the last declared first.

            It is rewritten as ... But that's only in math, in ruby code we have ...

            In context of operation=service objects, make deep nested is bad. Chaining is better for reusable.
          </aside>
        </section>
        <section data-auto-animate>
          <h2>Our current binder</h2>
          <pre data-id="binder" class="r-stretch"><code data-trim data-line-numbers="2-6|8-12|14-16" class="ruby">
            def call(user_id, address_id)
              user_service = FindUser.new.call(user_id) #=> FindUser instance
              unless user_service.success?
                add_errors(user_service.errors)
                return self
              end

              address_service = FindAddress.new.call(address_id) #=> FindAddress instance
              unless address_service.success?
                add_errors(address_service.errors)
                return self
              end

              unless user_service.user.update(address: address_service.address)
                add_errors(user_service.user.errors)
              end

              self
            end
          </code></pre>
        </section>
        <section data-auto-animate>
          <h2>Result binder</h2>
          <pre data-id="binder" class="r-stretch"><code data-trim data-line-numbers="2-3|5-6|8-12" class="ruby">
            def call(user_id, address_id)
              user_result = FindUser.new.call(user_id) #=> Success(user) OR Failure(errors)
              return user_result unless user_result.success?

              address_result = FindAddress.new.call(address_id) #=> Success(address) OR Failure(errors)
              return address_result unless address_result.success?

              if user_result.value!.update(address: address_result.value!)
                Success(user_result.value!)
              else
                Failure(user_result.value!.errors)
              end
            end
          </code></pre>
          <aside class="notes" data-markdown>
            It's already shorter.

            * You can see middle errors are just returned.
            * We can talk about why to popup errors to upper layer shortly later.
            * Now we can talk about the similarities.
          </aside>
        </section>
        <section>
          <div class="r-hstack justify-around">
            <h3 style="margin-bottom:0px">Current binder</h3>
            <h3>Result binder</h3>
          </div>
          <div class="r-hstack justify-around items-start">
            <div style="text-align:left">
              <p class="fragment" data-fragment-index="1"><code>#success? (#errors.empty?)</code><br>
              <code>#data</code></p>
              <p class="fragment" data-fragment-index="2"><span style="font-weight:bold">Service objects</span> are passed forward</p>
            </div>
            <div style="text-align:left">
              <p class="fragment" data-fragment-index="1"><code>Success(x) or Failure(e)</code><br>_</p>
              <p class="fragment" data-fragment-index="2"><span style="font-weight:bold">Result objects</span> are passed forward</p>
            </div>
          </div>
          <aside class="notes" data-markdown>
            * Current binder has 2 separate data in the service instance:...
            * Result binder return data with its context.

            Therefore, service objects need to be passed forward for current binder to work.
            While Result binder only need the returned result.
          </aside>
        </section>
        <section data-auto-animate>
          <h2>Handling errors in service objects</h2>
          <div>
            <img src="images/flow-basic.png" alt="basic service flow" data-id="error-flow">
            <pre data-id="error-code"><code data-trim data-line-numbers class="ruby">
              class B
                ...
                service = A.new.call
                unless service.success?
                  add_errors(service.errors) 
                end
                ...
              end
            </code></pre>
          </div>
          <aside class="notes" data-markdown>
            Service propagates errors to upper layer.
          </aside>
        </section>
        <section data-auto-animate>
          <h2>Handling errors in service objects</h2>
          <div>
            <img src="images/flow-swallow.png" alt="service swallows errors" data-id="error-flow">
            <pre data-id="error-code"><code data-trim data-line-numbers class="ruby">
              class B
                ...
                service = A.new.call
                unless service.success?
                  Sentry.notify(service.errors)
                end
                ...
              end
            </code></pre>
          </div>
          <aside class="notes" data-markdown>
            Service swallows errors.

            It reduces reusability.

            The actions for errors must be context dependent.
          </aside>
        </section>
        <section data-auto-animate>
          <h2>Handling errors in service objects</h2>
          <div>
            <img src="images/flow-both.png" alt="service does both" data-id="error-flow">
            <pre data-id="error-code"><code data-trim data-line-numbers="*|5" class="ruby">
              class B
                ...
                service = A.new.call
                unless service.success?
                  add_errors(service.errors) 
                  Sentry.notify(service.errors)
                end
                ...
              end
            </code></pre>
          </div>
          <aside class="notes" data-markdown>
            Can do both if Sentry step is important.

            But don't swallow errors.

            But line 5 is not that simple. And it's bad because of coupling on service A.

            This leads to the introduction of ROP.
          </aside>
        </section>
        <section data-auto-animate>
          <h2>Railway Oriented Programming</h2>
          <div>
            <img src="images/flow-rop.png" alt="rop" data-id="error-flow">
            <pre data-id="error-code"><code data-trim data-line-numbers class="ruby">
              class B
                ...
                result = A.new.call # Success or Failure
                return result unless result.success?
                ...
              end
            </code></pre>
          </div>
          <aside class="notes" data-markdown>
            ROP is essentially that. At the end, we can choose what to do with each error case.

            But it's seem too good to be true.

            I've been mentioning only Result monad. Stop here is fine already.

            Next part I will talk about Do-notation and other things to work this out.
          </aside>
        </section>
        <section data-auto-animate>
          <h2>#call</h2>
          <pre data-id="call-do" class="r-stretch"><code data-trim data-line-numbers="*|3-4|6-7|9-13|*" class="ruby">
            class UpdateUserAddress
              def call(user_id, address_id)
                user_result = FindUser.new.call(user_id) #=> Success(user) OR Failure(errors)
                return user_result unless user_result.success?

                address_result = FindAddress.new.call(address_id) #=> Success(address) OR Failure(errors)
                return address_result unless address_result.success?

                if user_result.value!.update(address: address_result.value!)
                  Success(user_result.value!)
                else
                  Failure(user_result.value!.errors)
                end
              end
            end
          </code></pre>
          <aside class="notes" data-markdown>
            This is the updating user address from previous slides.

            Drop errors on the red-stream, otherwise continue.
          </aside>
        </section>
        <section data-auto-animate>
          <h2>#call</h2>
          <pre data-id="call-do" class="r-stretch"><code data-trim data-line-numbers="*|2|5|6|8-12|*" class="ruby">
            class UpdateUserAddress
              include Dry::Monads[:do]

              def call(user_id, address_id)
                user = yield FindUser.new.call(user_id) #=> user
                address = yield FindAddress.new.call(address_id) #=> address

                if user.update(address: address)
                  Success(user)
                else
                  Failure(user.errors)
                end
              end
            end
          </code></pre>
          <aside class="notes" data-markdown>
            This doing the same. Do-notation gives just a tidier code.

            It auto-handles the red-stream, leaving only green-stream for better visual.
          </aside>
        </section>
      </div>
    </div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
